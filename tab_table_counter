import os
import csv
import argparse
import re
from docx import Document

# ---------- detection helpers ----------

_WORDY = re.compile(r"[A-Za-z0-9]{2,}")

def _is_sentencey(s: str) -> bool:
    # Long, punctuation-rich text reads like a sentence, not a table cell
    if not s:
        return False
    words = s.split()
    if len(words) >= 8:
        return True
    return bool(re.search(r"[.!?;:]", s)) and len(words) >= 6

def is_tabbed_row(txt: str) -> bool:
    """True if the line looks like a real 2+ column tabbed row."""
    if not txt or not txt.strip():
        return False

    parts = [p.strip() for p in txt.split("\t") if p.strip()]
    if len(parts) < 2:
        return False

    # Need real text in at least two parts
    real = [p for p in parts if _WORDY.search(p)]
    if len(real) < 2:
        return False

    # Guard against single-tab spacer sentences like "Re: ... \t CA No. ..."
    if len(parts) == 2:
        left, right = parts
        if _is_sentencey(left) or _is_sentencey(right) or len(txt) >= 120:
            return False

    return True

def _is_soft_gap(txt: str) -> bool:
    """Allow short spacer lines inside a tabbed table block."""
    if not txt or not txt.strip():
        return True  # blank line
    s = txt.strip()
    if len(s) <= 4:
        return True
    if set(s) <= set("_-.â€¢*"):
        return True
    return False

def normalize_snippet(txt: str, max_len: int = 200) -> str:
    """Readable snippet from a tabbed row."""
    s = " | ".join(p.strip() for p in txt.split("\t") if p.strip())
    s = re.sub(r"\s+", " ", s).strip()
    return s[:max_len]

# ---------- per-file processing ----------

def process_docx(file_path: str):
    """
    Count tabbed tables in the BODY (python-docx paragraphs)
    and collect one snippet per detected table, separated by newlines.
    """
    try:
        doc = Document(file_path)
    except Exception:
        return 0, ""

    count = 0
    snippets = []

    in_table_block = False
    gap = 0
    GAP_ALLOW = 1  # allow up to 1 soft spacer line inside a table

    for para in doc.paragraphs:
        txt = para.text or ""
        if is_tabbed_row(txt):
            if not in_table_block:
                count += 1
                snippets.append(normalize_snippet(txt))  # one snippet per table
                in_table_block = True
            gap = 0
        else:
            if in_table_block and _is_soft_gap(txt) and gap < GAP_ALLOW:
                gap += 1  # stay in same table
            else:
                in_table_block = False
                gap = 0

    return count, "\n".join(snippets)

# ---------- CLI / traversal ----------

def scan(root: str, out_csv: str):
    with open(out_csv, "w", newline="", encoding="utf-8") as f:
        w = csv.writer(f)
        w.writerow(["File Path", "Tabbed Table Count", "Snippet"])
        for dirpath, _, filenames in os.walk(root):
            for name in filenames:
                if name.lower().endswith(".docx"):
                    path = os.path.join(dirpath, name)
                    count, snippet = process_docx(path)
                    w.writerow([path, count, snippet])

def main():
    p = argparse.ArgumentParser(description="Detect tabbed tables in DOCX files.")
    p.add_argument("--root", required=True, help="Root directory to search")
    args = p.parse_args()

    out_csv = "tabbed_table_summary.csv"
    scan(args.root, out_csv)
    print(f"Saved: {out_csv}")

if __name__ == "__main__":
    main()
