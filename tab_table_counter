import os
import csv
import re
import argparse
from docx import Document

# ---------- detection helpers ----------

_PUNCT_ONLY = re.compile(r"^[\W_\.]+$")          # reject leaders/underscores/punct-only
_HAS_ALNUM   = re.compile(r"[A-Za-z0-9]{2,}")    # require real text in a column

def is_tabbed_row(txt: str) -> bool:
    """
    True if a line looks like a real 'tabbed-table' row:
    - at least 2 nonempty tab-separated parts
    - each 'kept' column must contain real text (not just dots/underscores/punct)
    """
    if not txt:
        return False
    parts = [p.strip() for p in txt.split("\t")]
    parts = [p for p in parts if p]  # drop empty
    if len(parts) < 2:
        return False
    good_cols = [p for p in parts if _HAS_ALNUM.search(p) and not _PUNCT_ONLY.match(p)]
    return len(good_cols) >= 2

def normalize_snippet(s: str) -> str:
    """Compact whitespace and tabs for the snippet preview."""
    s = s.strip()
    # collapse internal whitespace
    s = re.sub(r"\s+", " ", s)
    return s

# ---------- docx processing ----------

def process_docx(path: str):
    """
    Returns (tabbed_table_count, snippet_text)
    - Counts a 'table' as a *block* of consecutive tabbed rows.
    - Snippet shows up to two first rows from the first tables found.
    """
    try:
        doc = Document(path)
    except Exception:
        return 0, ""

    count = 0
    in_block = False
    snippets = []

    # doc.paragraphs only covers the document body, not headers/footers
    for para in doc.paragraphs:
        txt = para.text or ""
        if is_tabbed_row(txt):
            if not in_block:
                count += 1
                in_block = True
                if len(snippets) < 2:
                    snippets.append(normalize_snippet(txt))
            else:
                # still inside same table block; do not increment count
                pass
        else:
            in_block = False

        if len(snippets) >= 2 and count > 0:
            # we already have enough preview, keep scanning cheaply
            continue

    snippet_text = " / ".join(snippets)  # no trailing slash when only one
    return count, snippet_text

# ---------- CLI ----------

def main():
    ap = argparse.ArgumentParser(description="Count tabbed tables in DOCX files.")
    ap.add_argument("--root", required=True, help="Root directory to search")
    args = ap.parse_args()

    out_csv = "tabbed_table_summary.csv"
    with open(out_csv, "w", newline="", encoding="utf-8") as f:
        w = csv.writer(f)
        w.writerow(["File Path", "Tabbed Table Count", "Snippet"])
        for dirpath, _, filenames in os.walk(args.root):
            for fn in filenames:
                if fn.lower().endswith(".docx"):
                    fp = os.path.join(dirpath, fn)
                    count, snippet = process_docx(fp)
                    w.writerow([fp, count, snippet])

    print(f"Results saved to {out_csv}")

if __name__ == "__main__":
    main()
