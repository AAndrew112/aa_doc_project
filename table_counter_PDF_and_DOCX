# -------- DOCX tabbed “tables” (precision-focused) --------
POS_TOL_TWIPS = 60          # ~3 pt tolerance
MIN_SPAN_TWIPS = 2500       # ~2.0 inches (1 inch = 1440 twips)

def _docx_iter_paragraphs(zf: ZipFile):
    try:
        root = ET.fromstring(zf.read("word/document.xml"))
    except KeyError:
        return []
    return list(root.iter(f"{{{W_NS}}}p"))

def _para_tabstop_positions(p_el):
    pPr = p_el.find(f"{{{W_NS}}}pPr")
    if pPr is None: return None
    tabs = pPr.find(f"{{{W_NS}}}tabs")
    if tabs is None: return None
    pos = []
    for t in tabs.findall(f"{{{W_NS}}}tab"):
        val = t.get(f"{{{W_NS}}}pos")
        if val and val.isdigit():
            pos.append(int(val))
    if len(pos) < 2:  # need at least 2 stops to imply ≥3 cols
        return None
    pos = sorted(pos)
    # enforce overall span (filters header/signature indents)
    if pos[-1] - pos[0] < MIN_SPAN_TWIPS:
        return None
    return pos

def _aligned(pos_a, pos_b, tol=POS_TOL_TWIPS):
    if len(pos_a) != len(pos_b): return False
    return all(abs(a - b) <= tol for a, b in zip(pos_a, pos_b))

def count_tables_docx_tabbed(path: Path, min_cols=3, min_rows=3, allow_two_rows=False) -> int:
    """
    A 'tab table' = run of >= min_rows consecutive paragraphs with:
      • explicit tab-stop positions present,
      • at least (min_cols-1) tab stops,
      • same tab-stop positions (± tol) across the run,
      • overall tab-span ≥ MIN_SPAN_TWIPS (~2 in).
    Set allow_two_rows=True to accept 2-row runs (default False).
    """
    try:
        with ZipFile(path) as zf:
            paras = _docx_iter_paragraphs(zf)
    except Exception:
        return 0

    # collect paragraphs with usable tab-stop positions
    rows = []
    for i, p in enumerate(paras):
        pos = _para_tabstop_positions(p)
        if pos is not None and len(pos) >= (min_cols - 1):
            rows.append((i, pos))

    if not rows:
        return 0

    need_rows = 2 if allow_two_rows else max(3, min_rows)
    tab_tables, run = 0, []

    def finalize():
        nonlocal tab_tables, run
        if len(run) >= need_rows:
            base = run[0][1]
            if all(_aligned(base, r[1]) for r in run[1:]):
                tab_tables += 1
        run = []

    prev_i = None
    for rec in rows:
        i, pos = rec
        if prev_i is not None and i == prev_i + 1:
            if not run:
                # include previous row as start
                prev = next((r for r in rows if r[0] == prev_i), None)
                if prev: run.append(prev)
            run.append(rec)
        else:
            finalize()
            run = [rec]
        prev_i = i
    finalize()
    return tab_tables
