#!/usr/bin/env python3
from pathlib import Path
import argparse
import csv
import sys
from datetime import datetime
from docx import Document

def extract_text_and_highlight_blocks(path: Path, include_tables: bool, include_hf: bool, merge_across_paragraphs: bool):
    """
    Returns:
      - text: concatenated document text (paragraphs [+ optional tables, headers/footers])
      - highlight_blocks: number of contiguous highlighted blocks
        * By default, merges adjacent highlighted runs WITHIN a paragraph.
        * If merge_across_paragraphs=True, also merges when a paragraph ends highlighted and the next begins highlighted.
    """
    doc = Document(path)
    chunks = []
    highlight_blocks = 0

    # Carry state for cross-paragraph merging
    carry_in_block = False if merge_across_paragraphs else None

    def add_paragraphs(paragraphs):
        nonlocal highlight_blocks, carry_in_block
        for p in paragraphs:
            if p.text:
                chunks.append(p.text)

            in_block = bool(carry_in_block) if merge_across_paragraphs else False

            for r in p.runs:
                is_hl = bool(r.font and r.font.highlight_color)
                if is_hl and not in_block:
                    highlight_blocks += 1      # start of a new contiguous block
                    in_block = True
                elif not is_hl and in_block:
                    in_block = False

            # Pass along state across paragraphs only if requested
            if merge_across_paragraphs:
                carry_in_block = in_block

    # Body paragraphs
    add_paragraphs(doc.paragraphs)

    # Body tables
    if include_tables:
        for tbl in doc.tables:
            for row in tbl.rows:
                for cell in row.cells:
                    add_paragraphs(cell.paragraphs)

    # Headers/Footers (per section)
    if include_hf:
        for section in doc.sections:
            if section.header:
                add_paragraphs(section.header.paragraphs)
                for tbl in section.header.tables:
                    for row in tbl.rows:
                        for cell in row.cells:
                            add_paragraphs(cell.paragraphs)
            if section.footer:
                add_paragraphs(section.footer.paragraphs)
                for tbl in section.footer.tables:
                    for row in tbl.rows:
                        for cell in row.cells:
                            add_paragraphs(cell.paragraphs)

    return "\n".join(chunks), highlight_blocks

def count_pairs_and_empty(text: str):
    """
    Count total matched [ ... ] pairs and 'empty' pairs (content only whitespace).
    """
    stack = []
    pairs = 0
    empty_pairs = 0
    for i, ch in enumerate(text):
        if ch == "[":
            stack.append(i)
        elif ch == "]":
            if stack:
                start = stack.pop()
                pairs += 1
                if text[start+1:i].strip() == "":
                    empty_pairs += 1
    return pairs, empty_pairs

def timestamped_outpath(out_path: Path) -> Path:
    ts = datetime.now().strftime("%m%d%Y_%H%M")
    stem, suf = out_path.stem, (out_path.suffix or ".csv")
    return out_path.with_name(f"{stem}__{ts}{suf}")

def main():
    p = argparse.ArgumentParser(
        description="Scan .docx recursively; count bracket pairs (incl. empty); count highlighted blocks; write CSV."
    )
    p.add_argument("--root", type=Path, required=True, help="Root folder to search.")
    p.add_argument("--out", type=Path, default=Path("docx_bracket_counts.csv"),
                   help="Base output CSV filename (timestamp appended).")
    p.add_argument("--no-tables", action="store_true", help="Exclude table text.")
    p.add_argument("--no-headers-footers", action="store_true", help="Exclude headers/footers.")
    p.add_argument("--no-timestamp", action="store_true",
                   help="Do NOT append timestamp to output filename.")
    p.add_argument("--merge-across-paragraphs", action="store_true",
                   help="Merge contiguous highlighted blocks across paragraph boundaries (stricter merging).")
    args = p.parse_args()

    if not args.root.exists():
        p.error(f"--root path does not exist: {args.root}")

    include_tables = not args.no_tables
    include_hf = not args.no_headers_footers
    out_path = args.out if args.no_timestamp else timestamped_outpath(args.out)

    # [1/5] start + indexing
    files = list(args.root.rglob("*.docx"))
    print(f"[1/5] Indexed {len(files)} .docx files under {args.root}")

    results = []
    total = len(files)

    headers = [
        "File Path",
        "Bracket Pairs",
        "Empty Pairs",
        "Non-Empty Pairs",
        "Highlight Count",
        "Total Tags (with empty brackets)",
        "Total Tags (no empty brackets)"
    ]

    if total == 0:
        Path(out_path).parent.mkdir(parents=True, exist_ok=True)
        with open(out_path, "w", newline="", encoding="utf-8") as fp:
            writer = csv.DictWriter(fp, fieldnames=headers)
            writer.writeheader()
        print(f"[5/5] Done. Output: {out_path}")
        return

    # Progress checkpoints: 25%, 50%, 75%
    checkpoints = {0.25, 0.50, 0.75}
    fired = set()

    for idx, f in enumerate(files, start=1):
        try:
            text, highlight_blocks = extract_text_and_highlight_blocks(
                f, include_tables, include_hf, merge_across_paragraphs=args.merge_across_paragraphs
            )
            pairs, empty_pairs = count_pairs_and_empty(text)
            non_empty_pairs = pairs - empty_pairs

            # NEW total rules: take the higher of the two
            total_with_empty = max(pairs, highlight_blocks)          # Bracket Pairs vs Highlight Count
            total_no_empty = max(non_empty_pairs, highlight_blocks)  # Non-Empty Pairs vs Highlight Count

            results.append({
                "File Path": str(f),
                "Bracket Pairs": pairs,
                "Empty Pairs": empty_pairs,
                "Non-Empty Pairs": non_empty_pairs,
                "Highlight Count": highlight_blocks,
                "Total Tags (with empty brackets)": total_with_empty,
                "Total Tags (no empty brackets)": total_no_empty
            })
        except Exception as e:
            print(f"[error] {f}: {e}", file=sys.stderr)
            results.append({
                "File Path": str(f),
                "Bracket Pairs": "",
                "Empty Pairs": "",
                "Non-Empty Pairs": "",
                "Highlight Count": "",
                "Total Tags (with empty brackets)": "",
                "Total Tags (no empty brackets)": ""
            })

        # [2-4/5] at most three progress lines
        progress = idx / total
        for cp in (0.25, 0.50, 0.75):
            if progress >= cp and cp not in fired:
                pct = int(cp * 100)
                label = 2 if cp == 0.25 else 3 if cp == 0.50 else 4
                print(f"[{label}/5] ~{pct}% complete ({idx}/{total})")
                fired.add(cp)

    # Write CSV
    Path(out_path).parent.mkdir(parents=True, exist_ok=True)
    with open(out_path, "w", newline="", encoding="utf-8") as fp:
        writer = csv.DictWriter(fp, fieldnames=headers)
        writer.writeheader()
        writer.writerows(results)

    print(f"[5/5] Done. Wrote {len(results)} rows â†’ {out_path}")

if __name__ == "__main__":
    main()
