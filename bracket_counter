#!/usr/bin/env python3
from pathlib import Path
import argparse
import csv
import sys
from docx import Document

def extract_text_from_docx(path: Path, include_tables: bool, include_hf: bool) -> str:
    """Extract text from paragraphs (+ optional tables, headers, footers)."""
    doc = Document(path)
    chunks = []

    # Body paragraphs
    for p in doc.paragraphs:
        if p.text:
            chunks.append(p.text)

    # Body tables
    if include_tables:
        for tbl in doc.tables:
            for row in tbl.rows:
                for cell in row.cells:
                    if cell.text:
                        chunks.append(cell.text)

    # Headers/Footers (per section)
    if include_hf:
        for section in doc.sections:
            if section.header:
                for p in section.header.paragraphs:
                    if p.text:
                        chunks.append(p.text)
                for tbl in section.header.tables:
                    for row in tbl.rows:
                        for cell in row.cells:
                            if cell.text:
                                chunks.append(cell.text)
            if section.footer:
                for p in section.footer.paragraphs:
                    if p.text:
                        chunks.append(p.text)
                for tbl in section.footer.tables:
                    for row in tbl.rows:
                        for cell in row.cells:
                            if cell.text:
                                chunks.append(cell.text)

    return "\n".join(chunks)

def any_highlight_in_docx(path: Path, include_tables: bool, include_hf: bool) -> bool:
    """
    Returns True if any run in the document (including optional tables, headers/footers)
    has a highlight color set.
    """
    doc = Document(path)

    def runs_in_paragraphs(paragraphs):
        for p in paragraphs:
            for r in p.runs:
                yield r

    # Body paragraphs
    for r in runs_in_paragraphs(doc.paragraphs):
        if r.font and r.font.highlight_color:
            return True

    # Body tables
    if include_tables:
        for tbl in doc.tables:
            for row in tbl.rows:
                for cell in row.cells:
                    for r in runs_in_paragraphs(cell.paragraphs):
                        if r.font and r.font.highlight_color:
                            return True

    # Headers/Footers
    if include_hf:
        for section in doc.sections:
            if section.header:
                for r in runs_in_paragraphs(section.header.paragraphs):
                    if r.font and r.font.highlight_color:
                        return True
                for tbl in section.header.tables:
                    for row in tbl.rows:
                        for cell in row.cells:
                            for r in runs_in_paragraphs(cell.paragraphs):
                                if r.font and r.font.highlight_color:
                                    return True
            if section.footer:
                for r in runs_in_paragraphs(section.footer.paragraphs):
                    if r.font and r.font.highlight_color:
                        return True
                for tbl in section.footer.tables:
                    for row in tbl.rows:
                        for cell in row.cells:
                            for r in runs_in_paragraphs(cell.paragraphs):
                                if r.font and r.font.highlight_color:
                                    return True

    return False

def count_pairs_and_empty(text: str):
    """
    Single-pass bracket matcher using a stack.
    Counts total matched pairs and how many are 'empty' (only whitespace between [ and ]).
    Returns (pairs, empty_pairs).
    """
    stack = []  # store indices of '['
    pairs = 0
    empty_pairs = 0
    # Iterate characters and collect exact spans for matched pairs
    for i, ch in enumerate(text):
        if ch == "[":
            stack.append(i)
        elif ch == "]":
            if stack:
                start = stack.pop()
                pairs += 1
                inner = text[start+1:i]
                if inner.strip() == "":  # only whitespace or nothing
                    empty_pairs += 1
            else:
                # unmatched close; ignore for this report
                pass
    # unmatched opens remain in stack; we don't count them
    return pairs, empty_pairs

def scan(root: Path, include_tables: bool, include_hf: bool, want_highlight: bool, verbose: bool):
    """Yield result dicts for each .docx under root."""
    for f in root.rglob("*.docx"):
        if verbose:
            print(f"Scanning: {f}", file=sys.stderr)
        try:
            text = extract_text_from_docx(f, include_tables=include_tables, include_hf=include_hf)
            pairs, empty_pairs = count_pairs_and_empty(text)
            row = {
                "file_path": str(f),
                "pairs": pairs,
                "empty_pairs": empty_pairs
            }
            if want_highlight:
                try:
                    row["has_highlight"] = any_highlight_in_docx(f, include_tables, include_hf)
                except Exception as e:
                    if verbose:
                        print(f"Highlight check failed for {f}: {e}", file=sys.stderr)
                    row["has_highlight"] = ""
            yield row
        except Exception as e:
            if verbose:
                print(f"Error reading {f}: {e}", file=sys.stderr)
            row = {"file_path": str(f), "pairs": "", "empty_pairs": ""}
            if want_highlight:
                row["has_highlight"] = ""
            yield row

def main():
    print('starting process ...)
    p = argparse.ArgumentParser(
        description="Recursively scan .docx files and count bracket pairs, writing a minimal CSV."
    )
    p.add_argument("--root", type=Path, required=True, help="Root folder to search (recursively).")
    p.add_argument("--out", type=Path, default=Path("docx_bracket_counts.csv"),
                   help="Output CSV file path (default: docx_bracket_counts.csv)")
    p.add_argument("--no-tables", action="store_true", help="Exclude table text from counting.")
    p.add_argument("--no-headers-footers", action="store_true", help="Exclude headers/footers from counting.")
    p.add_argument("--highlight", action="store_true",
                   help="Also add a 'has_highlight' column (True/False) if any highlighted runs exist.")
    p.add_argument("-v", "--verbose", action="store_true", help="Print progress/errors to stderr.")

    args = p.parse_args()

    if not args.root.exists():
        p.error(f"--root path does not exist: {args.root}")

    include_tables = not args.no_tables
    include_hf = not args.no_headers_footers

    results = list(scan(args.root, include_tables, include_hf, args.highlight, args.verbose))

    # Columns: exactly as requested (file_path, pairs, empty_pairs); add has_highlight only if requested
    fieldnames = ["file_path", "pairs", "empty_pairs"]
    if args.highlight:
        fieldnames.append("has_highlight")

    args.out.parent.mkdir(parents=True, exist_ok=True)
    with args.out.open("w", newline="", encoding="utf-8") as fp:
        writer = csv.DictWriter(fp, fieldnames=fieldnames)
        writer.writeheader()
        writer.writerows(results)

    if args.verbose:
        print(f"\nWrote {len(results)} rows to {args.out}", file=sys.stderr)
    print('process complete')

if __name__ == "__main__":
    main()
