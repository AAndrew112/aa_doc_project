#!/usr/bin/env python3
from pathlib import Path
import argparse, csv, re
from zipfile import ZipFile
import xml.etree.ElementTree as ET

W_NS = "http://schemas.openxmlformats.org/wordprocessingml/2006/main"
NS = {"w": W_NS}
WORD_RE = re.compile(r"\boption\b", re.IGNORECASE)

def is_highlighted_run(r_el, para_highlight):
    """Return True if this run or its paragraph is highlighted."""
    rPr = r_el.find("w:rPr", NS)
    if rPr is not None:
        h = rPr.find("w:highlight", NS)
        if h is not None and (h.get(f"{{{W_NS}}}val") or "yes") != "none":
            return True
    # fallback to paragraph-level highlight
    return para_highlight

def get_para_highlight(p_el):
    """Return True if paragraph itself is highlighted."""
    pPr = p_el.find("w:pPr", NS)
    if pPr is None:
        return False
    h = pPr.find("w:highlight", NS)
    if h is not None and (h.get(f"{{{W_NS}}}val") or "yes") != "none":
        return True
    return False

def count_highlighted_option_docx(path: Path) -> int:
    """Count all highlighted 'option' words in a .docx file."""
    try:
        with ZipFile(path) as zf:
            xml = zf.read("word/document.xml")
    except Exception:
        return 0

    try:
        root = ET.fromstring(xml)
    except Exception:
        return 0

    total = 0
    for p in root.iter(f"{{{W_NS}}}p"):
        para_highlight = get_para_highlight(p)
        runs = list(p.findall("w:r", NS))
        merged_segments = []
        current = []
        for r in runs:
            if is_highlighted_run(r, para_highlight):
                # accumulate text from highlighted runs
                texts = [t.text or "" for t in r.findall("w:t", NS)]
                run_text = "".join(texts)
                current.append(run_text)
            else:
                if current:
                    merged_segments.append("".join(current))
                    current = []
        if current:
            merged_segments.append("".join(current))

        # Count word matches in all merged highlighted segments
        for seg in merged_segments:
            # Normalize punctuation spacing
            cleaned = re.sub(r"[^A-Za-z]", " ", seg)
            total += len(WORD_RE.findall(cleaned))
    return total


def main():
    p = argparse.ArgumentParser(
        description="Count highlighted occurrences of the word 'option' in DOCX files (high accuracy)."
    )
    p.add_argument("--root", type=Path, required=True, help="Root folder to search recursively.")
    p.add_argument("--out", type=Path, default=Path("highlighted_option_docx.csv"),
                   help="Output CSV file (File Path, Word Frequency).")
    args = p.parse_args()

    files = sorted([f for f in args.root.rglob("*.docx")])
    headers = ["File Path", "Word Frequency"]
    args.out.parent.mkdir(parents=True, exist_ok=True)

    with args.out.open("w", newline="", encoding="utf-8") as fp:
        import csv
        w = csv.DictWriter(fp, fieldnames=headers)
        w.writeheader()

        total = len(files)
        for idx, f in enumerate(files, 1):
            cnt = count_highlighted_option_docx(f)
            w.writerow({"File Path": str(f), "Word Frequency": cnt})
            if idx % 100 == 0 or idx == total:
                print(f"[progress] {idx}/{total} processed")

    print(f"[done] Wrote {len(files)} DOCX results â†’ {args.out}")

if __name__ == "__main__":
    main()
